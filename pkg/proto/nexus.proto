syntax = "proto3";

package nexus.v1;

option go_package = "github.com/haasonsaas/nexus/pkg/proto;proto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

// =============================================================================
// Services
// =============================================================================

// NexusGateway provides real-time bidirectional communication between clients
// and the Nexus AI gateway system.
service NexusGateway {
  // Stream establishes a bidirectional streaming connection for real-time
  // message exchange between client and server.
  rpc Stream(stream ClientMessage) returns (stream ServerMessage);
}

// SessionService manages conversation sessions.
service SessionService {
  // CreateSession creates a new conversation session.
  rpc CreateSession(CreateSessionRequest) returns (CreateSessionResponse);

  // GetSession retrieves a session by ID.
  rpc GetSession(GetSessionRequest) returns (GetSessionResponse);

  // ListSessions lists sessions with optional filtering.
  rpc ListSessions(ListSessionsRequest) returns (ListSessionsResponse);

  // DeleteSession deletes a session and its messages.
  rpc DeleteSession(DeleteSessionRequest) returns (DeleteSessionResponse);

  // UpdateSession updates session metadata.
  rpc UpdateSession(UpdateSessionRequest) returns (UpdateSessionResponse);
}

// AgentService manages AI agents.
service AgentService {
  // CreateAgent creates a new agent configuration.
  rpc CreateAgent(CreateAgentRequest) returns (CreateAgentResponse);

  // GetAgent retrieves an agent by ID.
  rpc GetAgent(GetAgentRequest) returns (GetAgentResponse);

  // ListAgents lists agents for a user.
  rpc ListAgents(ListAgentsRequest) returns (ListAgentsResponse);

  // UpdateAgent updates an agent configuration.
  rpc UpdateAgent(UpdateAgentRequest) returns (UpdateAgentResponse);

  // DeleteAgent deletes an agent.
  rpc DeleteAgent(DeleteAgentRequest) returns (DeleteAgentResponse);
}

// ChannelService manages channel connections.
service ChannelService {
  // ConnectChannel establishes a connection to a messaging platform.
  rpc ConnectChannel(ConnectChannelRequest) returns (ConnectChannelResponse);

  // DisconnectChannel disconnects from a messaging platform.
  rpc DisconnectChannel(DisconnectChannelRequest) returns (DisconnectChannelResponse);

  // GetChannelStatus retrieves the status of a channel connection.
  rpc GetChannelStatus(GetChannelStatusRequest) returns (GetChannelStatusResponse);

  // ListChannels lists all configured channels.
  rpc ListChannels(ListChannelsRequest) returns (ListChannelsResponse);
}

// HealthService provides health check functionality.
service HealthService {
  // Check performs a health check.
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);

  // Watch performs a streaming health check.
  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);
}

// NodeService manages device nodes (Mac, iPhone, etc.) for privileged actions.
service NodeService {
  // CreatePairingToken generates a token for pairing a new node.
  rpc CreatePairingToken(CreatePairingTokenRequest) returns (CreatePairingTokenResponse);

  // ListNodes returns all registered nodes.
  rpc ListNodes(ListNodesRequest) returns (ListNodesResponse);

  // GetNode retrieves a specific node.
  rpc GetNode(GetNodeRequest) returns (GetNodeResponse);

  // UpdateNode updates a node's configuration.
  rpc UpdateNode(UpdateNodeRequest) returns (UpdateNodeResponse);

  // RevokeNode revokes a node's access.
  rpc RevokeNode(RevokeNodeRequest) returns (RevokeNodeResponse);

  // DeleteNode permanently removes a node.
  rpc DeleteNode(DeleteNodeRequest) returns (DeleteNodeResponse);

  // RequestAction requests an action on a node (camera, screen, etc.).
  rpc RequestAction(RequestActionRequest) returns (RequestActionResponse);

  // GetNodeAuditLogs retrieves audit logs for a node.
  rpc GetNodeAuditLogs(GetNodeAuditLogsRequest) returns (GetNodeAuditLogsResponse);
}

// =============================================================================
// Streaming Messages
// =============================================================================

// ClientMessage represents messages sent from client to server.
message ClientMessage {
  oneof message {
    SendMessageRequest send_message = 1;
    SessionEvent session_event = 2;
    SubscribeRequest subscribe = 3;
    UnsubscribeRequest unsubscribe = 4;
    PingRequest ping = 5;
  }
}

// ServerMessage represents messages sent from server to client.
message ServerMessage {
  oneof message {
    MessageChunk message_chunk = 1;
    MessageComplete message_complete = 2;
    ToolCallRequest tool_call_request = 3;
    SessionEventNotification session_event_notification = 4;
    ErrorNotification error_notification = 5;
    PongResponse pong = 6;
  }
}

// SendMessageRequest sends a message to a session.
message SendMessageRequest {
  string session_id = 1;
  string content = 2;
  repeated Attachment attachments = 3;
  map<string, string> metadata = 4;
}

// MessageChunk represents a streaming chunk of an AI response.
message MessageChunk {
  string message_id = 1;
  string session_id = 2;
  string content = 3;
  int32 sequence = 4;
  ChunkType type = 5;
}

enum ChunkType {
  CHUNK_TYPE_UNSPECIFIED = 0;
  CHUNK_TYPE_TEXT = 1;
  CHUNK_TYPE_TOOL_CALL = 2;
  CHUNK_TYPE_METADATA = 3;
}

// MessageComplete indicates a message has finished streaming.
message MessageComplete {
  string message_id = 1;
  string session_id = 2;
  Message message = 3;
}

// ToolCallRequest requests the client to execute a tool.
message ToolCallRequest {
  string message_id = 1;
  string session_id = 2;
  repeated ToolCall tool_calls = 3;
}

// SessionEvent represents client-side events like typing indicators.
message SessionEvent {
  string session_id = 1;
  EventType event_type = 2;
  google.protobuf.Struct data = 3;
}

enum EventType {
  EVENT_TYPE_UNSPECIFIED = 0;
  EVENT_TYPE_TYPING_START = 1;
  EVENT_TYPE_TYPING_STOP = 2;
  EVENT_TYPE_READ = 3;
  EVENT_TYPE_PRESENCE = 4;
}

// SessionEventNotification broadcasts session events to subscribers.
message SessionEventNotification {
  string session_id = 1;
  EventType event_type = 2;
  google.protobuf.Struct data = 3;
  google.protobuf.Timestamp timestamp = 4;
}

// SubscribeRequest subscribes to updates for specific sessions.
message SubscribeRequest {
  repeated string session_ids = 1;
}

// UnsubscribeRequest unsubscribes from session updates.
message UnsubscribeRequest {
  repeated string session_ids = 1;
}

// PingRequest sends a ping to keep the connection alive.
message PingRequest {
  google.protobuf.Timestamp timestamp = 1;
}

// PongResponse responds to a ping.
message PongResponse {
  google.protobuf.Timestamp timestamp = 1;
}

// ErrorNotification notifies the client of an error.
message ErrorNotification {
  string code = 1;
  string message = 2;
  google.protobuf.Struct details = 3;
}

// =============================================================================
// Core Domain Messages
// =============================================================================

// Message represents a single message in a conversation.
message Message {
  string id = 1;
  string session_id = 2;
  ChannelType channel = 3;
  string channel_id = 4;
  Direction direction = 5;
  Role role = 6;
  string content = 7;
  repeated Attachment attachments = 8;
  repeated ToolCall tool_calls = 9;
  repeated ToolResult tool_results = 10;
  map<string, string> metadata = 11;
  google.protobuf.Timestamp created_at = 12;
}

enum ChannelType {
  CHANNEL_TYPE_UNSPECIFIED = 0;
  CHANNEL_TYPE_TELEGRAM = 1;
  CHANNEL_TYPE_DISCORD = 2;
  CHANNEL_TYPE_SLACK = 3;
  CHANNEL_TYPE_API = 4;
  CHANNEL_TYPE_IMESSAGE = 5;  // Edge-only: macOS iMessage
  CHANNEL_TYPE_SIGNAL = 6;    // Edge-only: Signal bridge
  CHANNEL_TYPE_WHATSAPP = 7;  // Edge-only: WhatsApp bridge
}

enum Direction {
  DIRECTION_UNSPECIFIED = 0;
  DIRECTION_INBOUND = 1;
  DIRECTION_OUTBOUND = 2;
}

enum Role {
  ROLE_UNSPECIFIED = 0;
  ROLE_USER = 1;
  ROLE_ASSISTANT = 2;
  ROLE_SYSTEM = 3;
  ROLE_TOOL = 4;
}

// Attachment represents a file or media attachment.
message Attachment {
  string id = 1;
  string type = 2; // image, audio, video, document
  string url = 3;
  string filename = 4;
  string mime_type = 5;
  int64 size = 6;
}

// ToolCall represents an LLM's request to execute a tool.
message ToolCall {
  string id = 1;
  string name = 2;
  string input = 3; // JSON-encoded input
}

// ToolResult represents the output of a tool execution.
message ToolResult {
  string tool_call_id = 1;
  string content = 2;
  bool is_error = 3;
}

// Session represents a conversation thread.
message Session {
  string id = 1;
  string agent_id = 2;
  ChannelType channel = 3;
  string channel_id = 4;
  string key = 5;
  string title = 6;
  map<string, string> metadata = 7;
  google.protobuf.Timestamp created_at = 8;
  google.protobuf.Timestamp updated_at = 9;
}

// Agent represents a configured AI agent.
message Agent {
  string id = 1;
  string user_id = 2;
  string name = 3;
  string system_prompt = 4;
  string model = 5;
  string provider = 6;
  repeated string tools = 7;
  map<string, string> config = 8;
  google.protobuf.Timestamp created_at = 9;
  google.protobuf.Timestamp updated_at = 10;
}

// User represents an authenticated user.
message User {
  string id = 1;
  string email = 2;
  string name = 3;
  string avatar_url = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
}

// APIKey represents an API key for programmatic access.
message APIKey {
  string id = 1;
  string user_id = 2;
  string name = 3;
  string prefix = 4;
  repeated string scopes = 5;
  google.protobuf.Timestamp last_used_at = 6;
  google.protobuf.Timestamp expires_at = 7;
  google.protobuf.Timestamp created_at = 8;
}

// =============================================================================
// Session Service Messages
// =============================================================================

message CreateSessionRequest {
  string agent_id = 1;
  ChannelType channel = 2;
  string channel_id = 3;
  string key = 4;
  string title = 5;
  map<string, string> metadata = 6;
}

message CreateSessionResponse {
  Session session = 1;
}

message GetSessionRequest {
  string id = 1;
}

message GetSessionResponse {
  Session session = 1;
}

message ListSessionsRequest {
  string agent_id = 1;
  ChannelType channel = 2;
  int32 page_size = 3;
  string page_token = 4;
}

message ListSessionsResponse {
  repeated Session sessions = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

message DeleteSessionRequest {
  string id = 1;
}

message DeleteSessionResponse {
  bool success = 1;
}

message UpdateSessionRequest {
  string id = 1;
  string title = 2;
  map<string, string> metadata = 3;
}

message UpdateSessionResponse {
  Session session = 1;
}

// =============================================================================
// Agent Service Messages
// =============================================================================

message CreateAgentRequest {
  string user_id = 1;
  string name = 2;
  string system_prompt = 3;
  string model = 4;
  string provider = 5;
  repeated string tools = 6;
  map<string, string> config = 7;
}

message CreateAgentResponse {
  Agent agent = 1;
}

message GetAgentRequest {
  string id = 1;
}

message GetAgentResponse {
  Agent agent = 1;
}

message ListAgentsRequest {
  string user_id = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListAgentsResponse {
  repeated Agent agents = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

message UpdateAgentRequest {
  string id = 1;
  string name = 2;
  string system_prompt = 3;
  string model = 4;
  string provider = 5;
  repeated string tools = 6;
  map<string, string> config = 7;
}

message UpdateAgentResponse {
  Agent agent = 1;
}

message DeleteAgentRequest {
  string id = 1;
}

message DeleteAgentResponse {
  bool success = 1;
}

// =============================================================================
// Channel Service Messages
// =============================================================================

message ConnectChannelRequest {
  ChannelType channel_type = 1;
  string channel_id = 2;
  map<string, string> credentials = 3;
  map<string, string> config = 4;
}

message ConnectChannelResponse {
  ChannelConnection connection = 1;
}

message DisconnectChannelRequest {
  string connection_id = 1;
}

message DisconnectChannelResponse {
  bool success = 1;
}

message GetChannelStatusRequest {
  string connection_id = 1;
}

message GetChannelStatusResponse {
  ChannelConnection connection = 1;
}

message ListChannelsRequest {
  string user_id = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListChannelsResponse {
  repeated ChannelConnection connections = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

message ChannelConnection {
  string id = 1;
  string user_id = 2;
  ChannelType channel_type = 3;
  string channel_id = 4;
  ConnectionStatus status = 5;
  map<string, string> config = 6;
  google.protobuf.Timestamp connected_at = 7;
  google.protobuf.Timestamp last_activity_at = 8;
}

enum ConnectionStatus {
  CONNECTION_STATUS_UNSPECIFIED = 0;
  CONNECTION_STATUS_CONNECTED = 1;
  CONNECTION_STATUS_DISCONNECTED = 2;
  CONNECTION_STATUS_ERROR = 3;
  CONNECTION_STATUS_CONNECTING = 4;
}

// =============================================================================
// Health Service Messages
// =============================================================================

message HealthCheckRequest {
  string service = 1;
}

message HealthCheckResponse {
  ServingStatus status = 1;
  map<string, string> metadata = 2;
  google.protobuf.Timestamp timestamp = 3;
}

enum ServingStatus {
  SERVING_STATUS_UNKNOWN = 0;
  SERVING_STATUS_SERVING = 1;
  SERVING_STATUS_NOT_SERVING = 2;
  SERVING_STATUS_SERVICE_UNKNOWN = 3;
}

// =============================================================================
// Edge Service - Protocol for edge daemon communication
// =============================================================================

// EdgeService manages edge daemon connections and tool execution.
// Edge daemons connect from user machines to provide local capabilities
// like device access, browser relay, and edge-only channels.
service EdgeService {
  // Connect establishes a bidirectional stream between edge and core.
  // The edge sends registration, heartbeats, and tool results.
  // The core sends tool execution requests and control messages.
  rpc Connect(stream EdgeMessage) returns (stream CoreMessage);

  // GetEdgeStatus returns the status of a connected edge.
  rpc GetEdgeStatus(GetEdgeStatusRequest) returns (GetEdgeStatusResponse);

  // ListEdges returns all connected edges.
  rpc ListEdges(ListEdgesRequest) returns (ListEdgesResponse);
}

// =============================================================================
// Node Messages
// =============================================================================

// NodeStatus represents the current state of a node.
enum NodeStatus {
  NODE_STATUS_UNSPECIFIED = 0;
  NODE_STATUS_PENDING = 1;    // Has pairing token, not yet connected
  NODE_STATUS_ONLINE = 2;     // Currently connected
  NODE_STATUS_OFFLINE = 3;    // Previously connected, now disconnected
  NODE_STATUS_REVOKED = 4;    // Access revoked
}

// NodeCapability represents what a node can do.
enum NodeCapability {
  NODE_CAPABILITY_UNSPECIFIED = 0;
  NODE_CAPABILITY_CAMERA = 1;
  NODE_CAPABILITY_SCREEN = 2;
  NODE_CAPABILITY_LOCATION = 3;
  NODE_CAPABILITY_FILESYSTEM = 4;
  NODE_CAPABILITY_SHELL = 5;
  NODE_CAPABILITY_BROWSER = 6;
  NODE_CAPABILITY_CHANNELS = 7;
}

// Node represents a registered device.
message Node {
  string id = 1;
  string name = 2;
  string device_type = 3;
  string owner_id = 4;
  NodeStatus status = 5;
  repeated NodeCapability capabilities = 6;
  repeated string channel_types = 7;
  string edge_id = 8;
  google.protobuf.Timestamp last_seen_at = 9;
  map<string, string> metadata = 10;
  google.protobuf.Timestamp created_at = 11;
  google.protobuf.Timestamp updated_at = 12;
}

// PairingToken for registering a new node.
message PairingToken {
  string token = 1;
  string node_id = 2;
  string name = 3;
  string device_type = 4;
  google.protobuf.Timestamp expires_at = 5;
  google.protobuf.Timestamp created_at = 6;
}

message CreatePairingTokenRequest {
  string name = 1;
  string device_type = 2;
}

message CreatePairingTokenResponse {
  PairingToken token = 1;
}

message ListNodesRequest {
  string owner_id = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListNodesResponse {
  repeated Node nodes = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

message GetNodeRequest {
  string node_id = 1;
}

message GetNodeResponse {
  Node node = 1;
}

message UpdateNodeRequest {
  string node_id = 1;
  string name = 2;
  map<string, string> metadata = 3;
}

message UpdateNodeResponse {
  Node node = 1;
}

message RevokeNodeRequest {
  string node_id = 1;
}

message RevokeNodeResponse {
  bool success = 1;
}

message DeleteNodeRequest {
  string node_id = 1;
}

message DeleteNodeResponse {
  bool success = 1;
}

// RequestActionRequest requests an action on a node.
message RequestActionRequest {
  string node_id = 1;
  NodeCapability capability = 2;
  map<string, string> parameters = 3;
}

// RequestActionResponse returns the result of a node action.
message RequestActionResponse {
  bool success = 1;
  string error = 2;
  bytes data = 3;
  map<string, string> metadata = 4;
}

// NodeAuditLog records an action on a node.
message NodeAuditLog {
  string id = 1;
  string node_id = 2;
  string action = 3;
  string user_id = 4;
  google.protobuf.Struct details = 5;
  google.protobuf.Timestamp timestamp = 6;
}

message GetNodeAuditLogsRequest {
  string node_id = 1;
  int32 limit = 2;
}

message GetNodeAuditLogsResponse {
  repeated NodeAuditLog logs = 1;
}

// =============================================================================
// Edge Protocol Messages
// =============================================================================

// EdgeMessage represents messages sent from edge daemon to core.
message EdgeMessage {
  oneof message {
    EdgeRegister register = 1;
    EdgeHeartbeat heartbeat = 2;
    ToolExecutionResult tool_result = 3;
    EdgeEvent event = 4;
    EdgeChannelInbound channel_inbound = 5;   // Channel message from user
    EdgeChannelAck channel_ack = 6;           // Delivery acknowledgment
  }
}

// CoreMessage represents messages sent from core to edge daemon.
message CoreMessage {
  oneof message {
    EdgeRegistered registered = 1;
    ToolExecutionRequest tool_request = 2;
    ToolCancellation tool_cancel = 3;
    CoreEvent event = 4;
    CoreChannelOutbound channel_outbound = 5;   // Channel message to user
  }
}

// EdgeRegister is sent by the edge to register with the core.
message EdgeRegister {
  // Unique identifier for this edge instance.
  string edge_id = 1;

  // Human-readable name for this edge.
  string name = 2;

  // Authentication token (pre-shared secret or TOFU token).
  string auth_token = 3;

  // Tools this edge provides.
  repeated EdgeToolDefinition tools = 4;

  // Channels this edge can host (for edge-only channels like iMessage).
  repeated string channel_types = 5;

  // Capabilities flags.
  EdgeCapabilities capabilities = 6;

  // Edge version for compatibility checks.
  string version = 7;

  // Metadata about the edge environment.
  map<string, string> metadata = 8;
}

// EdgeToolDefinition describes a tool provided by the edge.
message EdgeToolDefinition {
  // Tool name (will be prefixed with edge:<edge_id>.).
  string name = 1;

  // Human-readable description for the LLM.
  string description = 2;

  // JSON Schema for tool parameters.
  string input_schema = 3;

  // Whether this tool requires approval before execution.
  bool requires_approval = 4;

  // Timeout for this tool in seconds (0 = use default).
  int32 timeout_seconds = 5;

  // Whether this tool can produce artifacts (files, screenshots, etc.).
  bool produces_artifacts = 6;
}

// EdgeCapabilities describes what the edge can do.
message EdgeCapabilities {
  // Can execute arbitrary tools.
  bool tools = 1;

  // Can host channel adapters.
  bool channels = 2;

  // Can stream tool execution progress.
  bool streaming = 3;

  // Can handle artifact uploads.
  bool artifacts = 4;
}

// EdgeRegistered confirms successful registration.
message EdgeRegistered {
  // Whether registration was successful.
  bool success = 1;

  // Error message if registration failed.
  string error = 2;

  // Assigned edge ID (may differ from requested if conflict).
  string edge_id = 3;

  // Heartbeat interval in seconds.
  int32 heartbeat_interval_seconds = 4;

  // Core version for compatibility.
  string core_version = 5;
}

// EdgeHeartbeat keeps the connection alive and reports status.
message EdgeHeartbeat {
  // Edge identifier.
  string edge_id = 1;

  // Timestamp of heartbeat.
  google.protobuf.Timestamp timestamp = 2;

  // Current load metrics.
  EdgeMetrics metrics = 3;

  // Tools currently executing.
  repeated string active_tools = 4;
}

// EdgeMetrics reports edge daemon health.
message EdgeMetrics {
  // Number of tools currently executing.
  int32 active_tool_count = 1;

  // CPU usage percentage (0-100).
  float cpu_percent = 2;

  // Memory usage in bytes.
  int64 memory_bytes = 3;

  // Uptime in seconds.
  int64 uptime_seconds = 4;
}

// ToolExecutionRequest asks the edge to execute a tool.
message ToolExecutionRequest {
  // Unique ID for this execution (for correlation).
  string execution_id = 1;

  // Run ID for tracing across the agent loop.
  string run_id = 2;

  // Session ID for context.
  string session_id = 3;

  // Tool name (without edge: prefix).
  string tool_name = 4;

  // JSON-encoded tool parameters.
  string input = 5;

  // Timeout in seconds.
  int32 timeout_seconds = 6;

  // Whether approval was already granted.
  bool approved = 7;

  // Metadata for the execution.
  map<string, string> metadata = 8;
}

// ToolExecutionResult returns the result of a tool execution.
message ToolExecutionResult {
  // Execution ID for correlation.
  string execution_id = 1;

  // Tool output content.
  string content = 2;

  // Whether this is an error result.
  bool is_error = 3;

  // Execution duration in milliseconds.
  int64 duration_ms = 4;

  // Artifacts produced by the tool.
  repeated Artifact artifacts = 5;

  // Detailed error information if is_error is true.
  string error_details = 6;
}

// Artifact represents a file or data produced by tool execution.
message Artifact {
  // Unique artifact ID.
  string id = 1;

  // Artifact type (screenshot, recording, file, etc.).
  string type = 2;

  // MIME type.
  string mime_type = 3;

  // Filename.
  string filename = 4;

  // Size in bytes.
  int64 size = 5;

  // URL or reference to retrieve the artifact.
  string reference = 6;

  // Inline data for small artifacts (< 1MB).
  bytes data = 7;

  // TTL in seconds (0 = default retention).
  int32 ttl_seconds = 8;
}

// ToolCancellation requests cancellation of a running tool.
message ToolCancellation {
  // Execution ID to cancel.
  string execution_id = 1;

  // Reason for cancellation.
  string reason = 2;
}

// EdgeEvent represents events from edge to core.
message EdgeEvent {
  // Edge identifier.
  string edge_id = 1;

  // Event type.
  EdgeEventType type = 2;

  // Event timestamp.
  google.protobuf.Timestamp timestamp = 3;

  // Event-specific data.
  google.protobuf.Struct data = 4;
}

enum EdgeEventType {
  EDGE_EVENT_TYPE_UNSPECIFIED = 0;
  EDGE_EVENT_TYPE_TOOL_STARTED = 1;
  EDGE_EVENT_TYPE_TOOL_PROGRESS = 2;
  EDGE_EVENT_TYPE_TOOL_COMPLETED = 3;
  EDGE_EVENT_TYPE_TOOL_FAILED = 4;
  EDGE_EVENT_TYPE_TOOL_CANCELLED = 5;
  EDGE_EVENT_TYPE_APPROVAL_REQUIRED = 6;
  EDGE_EVENT_TYPE_ARTIFACT_READY = 7;
  EDGE_EVENT_TYPE_CHANNEL_MESSAGE = 8;
  EDGE_EVENT_TYPE_DISCONNECTING = 9;
}

// CoreEvent represents events from core to edge.
message CoreEvent {
  // Event type.
  CoreEventType type = 1;

  // Event timestamp.
  google.protobuf.Timestamp timestamp = 2;

  // Event-specific data.
  google.protobuf.Struct data = 3;
}

enum CoreEventType {
  CORE_EVENT_TYPE_UNSPECIFIED = 0;
  CORE_EVENT_TYPE_APPROVAL_GRANTED = 1;
  CORE_EVENT_TYPE_APPROVAL_DENIED = 2;
  CORE_EVENT_TYPE_CONFIG_UPDATE = 3;
  CORE_EVENT_TYPE_SHUTDOWN = 4;
}

// =============================================================================
// Edge Channel Messages
// =============================================================================

// EdgeChannelInbound forwards an inbound message from an edge-hosted channel.
// Used for channels that can only run locally (iMessage, Signal, etc.).
message EdgeChannelInbound {
  // Edge identifier.
  string edge_id = 1;

  // Channel type (must be an edge-only type like IMESSAGE, SIGNAL).
  ChannelType channel_type = 2;

  // Channel-specific identifier (e.g., phone number, chat ID).
  string channel_id = 3;

  // Session key for routing (derived from channel_id + user context).
  string session_key = 4;

  // The normalized message content.
  string content = 5;

  // Sender information.
  string sender_id = 6;
  string sender_name = 7;

  // Attachments (images, files, etc.).
  repeated Attachment attachments = 8;

  // Channel-specific metadata.
  map<string, string> metadata = 9;

  // When the message was received by the edge.
  google.protobuf.Timestamp received_at = 10;
}

// CoreChannelOutbound sends an outbound message through an edge channel.
message CoreChannelOutbound {
  // Unique message ID for acknowledgment.
  string message_id = 1;

  // Session ID this message belongs to.
  string session_id = 2;

  // Channel type to send through.
  ChannelType channel_type = 3;

  // Channel-specific destination (phone number, chat ID).
  string channel_id = 4;

  // The message content to send.
  string content = 5;

  // Attachments to send.
  repeated Attachment attachments = 6;

  // Reply context if this is a reply.
  string reply_to_id = 7;

  // Channel-specific options.
  map<string, string> options = 8;
}

// EdgeChannelAck acknowledges receipt/delivery of an outbound message.
message EdgeChannelAck {
  // The message ID being acknowledged.
  string message_id = 1;

  // Delivery status.
  ChannelDeliveryStatus status = 2;

  // Error message if delivery failed.
  string error = 3;

  // Channel-assigned message ID after sending.
  string external_id = 4;

  // When the message was delivered.
  google.protobuf.Timestamp delivered_at = 5;
}

enum ChannelDeliveryStatus {
  CHANNEL_DELIVERY_STATUS_UNSPECIFIED = 0;
  CHANNEL_DELIVERY_STATUS_SENT = 1;
  CHANNEL_DELIVERY_STATUS_DELIVERED = 2;
  CHANNEL_DELIVERY_STATUS_READ = 3;
  CHANNEL_DELIVERY_STATUS_FAILED = 4;
}

// =============================================================================
// Edge Status Messages
// =============================================================================

message GetEdgeStatusRequest {
  string edge_id = 1;
}

message GetEdgeStatusResponse {
  EdgeStatus status = 1;
}

message ListEdgesRequest {
  int32 page_size = 1;
  string page_token = 2;
}

message ListEdgesResponse {
  repeated EdgeStatus edges = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

// EdgeStatus describes the current state of an edge.
message EdgeStatus {
  // Edge identifier.
  string edge_id = 1;

  // Human-readable name.
  string name = 2;

  // Connection status.
  EdgeConnectionStatus connection_status = 3;

  // When the edge connected.
  google.protobuf.Timestamp connected_at = 4;

  // Last heartbeat received.
  google.protobuf.Timestamp last_heartbeat = 5;

  // Tools registered by this edge.
  repeated string tools = 6;

  // Channel types this edge can host.
  repeated string channel_types = 7;

  // Latest metrics.
  EdgeMetrics metrics = 8;

  // Edge version.
  string version = 9;

  // Edge metadata.
  map<string, string> metadata = 10;
}

enum EdgeConnectionStatus {
  EDGE_CONNECTION_STATUS_UNSPECIFIED = 0;
  EDGE_CONNECTION_STATUS_CONNECTED = 1;
  EDGE_CONNECTION_STATUS_DISCONNECTED = 2;
  EDGE_CONNECTION_STATUS_RECONNECTING = 3;
}

// RiskLevel indicates the risk level of a tool operation.
enum RiskLevel {
  RISK_LEVEL_UNSPECIFIED = 0;
  RISK_LEVEL_LOW = 1;       // Read-only, no side effects
  RISK_LEVEL_MEDIUM = 2;    // May have side effects, reversible
  RISK_LEVEL_HIGH = 3;      // Significant side effects
  RISK_LEVEL_CRITICAL = 4;  // Destructive or security-sensitive
}

// ToolCategory categorizes tools for policy and display.
enum ToolCategory {
  TOOL_CATEGORY_UNSPECIFIED = 0;
  TOOL_CATEGORY_SYSTEM = 1;       // System access (files, processes)
  TOOL_CATEGORY_HARDWARE = 2;     // Hardware access (camera, sensors)
  TOOL_CATEGORY_NETWORK = 3;      // Network operations
  TOOL_CATEGORY_COMMUNICATION = 4; // Messaging, notifications
  TOOL_CATEGORY_DATA = 5;         // Data processing
  TOOL_CATEGORY_AUTOMATION = 6;   // Scripts, workflows
  TOOL_CATEGORY_CUSTOM = 7;       // User-defined
}

// =============================================================================
// Event Timeline Service - For debugging and observability
// =============================================================================

// EventService provides access to the event timeline for debugging.
service EventService {
  // GetEvents retrieves events by run ID or session ID.
  rpc GetEvents(GetEventsRequest) returns (GetEventsResponse);

  // GetTimeline retrieves a formatted timeline for a run.
  rpc GetTimeline(GetTimelineRequest) returns (GetTimelineResponse);
}

message GetEventsRequest {
  // Query by run_id (preferred for debugging a single run).
  string run_id = 1;

  // Query by session_id (all events for a session).
  string session_id = 2;

  // Maximum number of events to return.
  int32 limit = 3;

  // Filter by event type (e.g., "tool", "llm", "edge").
  string type_filter = 4;
}

message GetEventsResponse {
  repeated TimelineEvent events = 1;
  int32 total_count = 2;
}

message GetTimelineRequest {
  string run_id = 1;
  string session_id = 2;
}

message GetTimelineResponse {
  string run_id = 1;
  string session_id = 2;
  google.protobuf.Timestamp start_time = 3;
  google.protobuf.Timestamp end_time = 4;
  int64 duration_ms = 5;
  repeated TimelineEvent events = 6;
  TimelineSummary summary = 7;
  string formatted = 8;  // Pre-formatted text output for CLI
}

message TimelineEvent {
  string id = 1;
  string type = 2;
  google.protobuf.Timestamp timestamp = 3;
  string run_id = 4;
  string session_id = 5;
  string tool_call_id = 6;
  string edge_id = 7;
  string name = 8;
  string description = 9;
  int64 duration_ms = 10;
  string error = 11;
  map<string, string> data = 12;
}

message TimelineSummary {
  int32 total_events = 1;
  int32 error_count = 2;
  int32 tool_calls = 3;
  int32 llm_calls = 4;
  int32 edge_events = 5;
  int64 total_duration_ms = 6;
}

// =============================================================================
// Task Service - Scheduled/Proactive Messaging
// =============================================================================

// TaskService manages scheduled tasks for proactive messaging and automation.
service TaskService {
  // CreateTask creates a new scheduled task.
  rpc CreateTask(CreateTaskRequest) returns (CreateTaskResponse);

  // GetTask retrieves a task by ID.
  rpc GetTask(GetTaskRequest) returns (GetTaskResponse);

  // ListTasks lists tasks with optional filtering.
  rpc ListTasks(ListTasksRequest) returns (ListTasksResponse);

  // UpdateTask updates an existing task.
  rpc UpdateTask(UpdateTaskRequest) returns (UpdateTaskResponse);

  // DeleteTask deletes a task.
  rpc DeleteTask(DeleteTaskRequest) returns (DeleteTaskResponse);

  // PauseTask pauses a task's schedule.
  rpc PauseTask(PauseTaskRequest) returns (PauseTaskResponse);

  // ResumeTask resumes a paused task.
  rpc ResumeTask(ResumeTaskRequest) returns (ResumeTaskResponse);

  // TriggerTask manually triggers a task to run immediately.
  rpc TriggerTask(TriggerTaskRequest) returns (TriggerTaskResponse);

  // ListExecutions lists executions for a task.
  rpc ListExecutions(ListExecutionsRequest) returns (ListExecutionsResponse);
}

// MessageService provides proactive message sending capabilities.
service MessageService {
  // SendMessage sends a message to a specific channel/peer without requiring an inbound message.
  rpc SendMessage(ProactiveSendRequest) returns (ProactiveSendResponse);

  // BroadcastMessage sends a message to multiple recipients.
  rpc BroadcastMessage(BroadcastMessageRequest) returns (BroadcastMessageResponse);
}

// ScheduledTask represents a task that runs on a schedule.
message ScheduledTask {
  // Unique identifier.
  string id = 1;

  // Human-readable name.
  string name = 2;

  // Task description.
  string description = 3;

  // Agent to execute the task.
  string agent_id = 4;

  // Cron expression (standard 5-field or extended 6-field with seconds).
  string schedule = 5;

  // Timezone for schedule (e.g., "America/New_York"). Defaults to UTC.
  string timezone = 6;

  // Prompt to send to the agent when task executes.
  string prompt = 7;

  // Task configuration.
  TaskConfig config = 8;

  // Current status.
  TaskStatus status = 9;

  // Next scheduled run time.
  google.protobuf.Timestamp next_run_at = 10;

  // Last run time.
  google.protobuf.Timestamp last_run_at = 11;

  // Last execution ID.
  string last_execution_id = 12;

  // Creation timestamp.
  google.protobuf.Timestamp created_at = 13;

  // Last update timestamp.
  google.protobuf.Timestamp updated_at = 14;

  // Arbitrary metadata.
  map<string, string> metadata = 15;
}

// TaskConfig holds task configuration options.
message TaskConfig {
  // Timeout in seconds (default: 300).
  int32 timeout_seconds = 1;

  // Number of retry attempts on failure.
  int32 max_retries = 2;

  // Delay between retries in seconds.
  int32 retry_delay_seconds = 3;

  // Allow overlapping executions.
  bool allow_overlap = 4;

  // Channel type for execution context.
  string channel = 5;

  // Channel ID for execution context.
  string channel_id = 6;

  // Fixed session ID (optional, creates new if empty).
  string session_id = 7;

  // Override system prompt for this task.
  string system_prompt = 8;

  // Override model for this task.
  string model = 9;

  // Target peer for proactive messages.
  string target_peer_id = 10;
}

enum TaskStatus {
  TASK_STATUS_UNSPECIFIED = 0;
  TASK_STATUS_ACTIVE = 1;
  TASK_STATUS_PAUSED = 2;
  TASK_STATUS_DISABLED = 3;
}

// TaskExecution represents a single execution of a task.
message TaskExecution {
  string id = 1;
  string task_id = 2;
  ExecutionStatus status = 3;
  google.protobuf.Timestamp scheduled_at = 4;
  google.protobuf.Timestamp started_at = 5;
  google.protobuf.Timestamp finished_at = 6;
  string session_id = 7;
  string prompt = 8;
  string response = 9;
  string error = 10;
  int32 attempt_number = 11;
  int64 duration_ms = 12;
}

enum ExecutionStatus {
  EXECUTION_STATUS_UNSPECIFIED = 0;
  EXECUTION_STATUS_PENDING = 1;
  EXECUTION_STATUS_RUNNING = 2;
  EXECUTION_STATUS_SUCCEEDED = 3;
  EXECUTION_STATUS_FAILED = 4;
  EXECUTION_STATUS_TIMED_OUT = 5;
  EXECUTION_STATUS_CANCELLED = 6;
}

// Task Service Request/Response Messages
message CreateTaskRequest {
  string name = 1;
  string description = 2;
  string agent_id = 3;
  string schedule = 4;
  string timezone = 5;
  string prompt = 6;
  TaskConfig config = 7;
  map<string, string> metadata = 8;
}

message CreateTaskResponse {
  ScheduledTask task = 1;
}

message GetTaskRequest {
  string id = 1;
}

message GetTaskResponse {
  ScheduledTask task = 1;
}

message ListTasksRequest {
  string agent_id = 1;
  TaskStatus status = 2;
  int32 page_size = 3;
  string page_token = 4;
}

message ListTasksResponse {
  repeated ScheduledTask tasks = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

message UpdateTaskRequest {
  string id = 1;
  string name = 2;
  string description = 3;
  string schedule = 4;
  string timezone = 5;
  string prompt = 6;
  TaskConfig config = 7;
  map<string, string> metadata = 8;
}

message UpdateTaskResponse {
  ScheduledTask task = 1;
}

message DeleteTaskRequest {
  string id = 1;
}

message DeleteTaskResponse {
  bool success = 1;
}

message PauseTaskRequest {
  string id = 1;
}

message PauseTaskResponse {
  ScheduledTask task = 1;
}

message ResumeTaskRequest {
  string id = 1;
}

message ResumeTaskResponse {
  ScheduledTask task = 1;
}

message TriggerTaskRequest {
  string id = 1;
}

message TriggerTaskResponse {
  TaskExecution execution = 1;
}

message ListExecutionsRequest {
  string task_id = 1;
  ExecutionStatus status = 2;
  int32 page_size = 3;
  string page_token = 4;
}

message ListExecutionsResponse {
  repeated TaskExecution executions = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

// Proactive Message Service Request/Response Messages
message ProactiveSendRequest {
  // Channel type to send to.
  string channel = 1;

  // Channel-specific recipient ID (e.g., chat_id for Telegram).
  string peer_id = 2;

  // Message content.
  string content = 3;

  // Optional agent ID for context.
  string agent_id = 4;

  // Optional session ID for conversation continuity.
  string session_id = 5;

  // Optional attachments.
  repeated Attachment attachments = 6;

  // Message metadata.
  map<string, string> metadata = 7;
}

message ProactiveSendResponse {
  // Whether the message was sent successfully.
  bool success = 1;

  // Message ID assigned by the channel.
  string message_id = 2;

  // Session ID (created if not provided).
  string session_id = 3;

  // Error message if failed.
  string error = 4;
}

message BroadcastMessageRequest {
  // Channel type to send to.
  string channel = 1;

  // List of peer IDs to send to.
  repeated string peer_ids = 2;

  // Message content.
  string content = 3;

  // Optional agent ID.
  string agent_id = 4;

  // Optional attachments.
  repeated Attachment attachments = 5;

  // Message metadata.
  map<string, string> metadata = 6;
}

message BroadcastMessageResponse {
  // Number of messages sent successfully.
  int32 success_count = 1;

  // Number of messages that failed.
  int32 failure_count = 2;

  // Details per recipient.
  repeated BroadcastResult results = 3;
}

message BroadcastResult {
  string peer_id = 1;
  bool success = 2;
  string message_id = 3;
  string error = 4;
}

// =============================================================================
// Identity Service - Cross-channel User Identity Linking
// =============================================================================

// IdentityService manages cross-channel identity linking.
// This allows mapping platform-specific user IDs (e.g., telegram:123456) to
// canonical identities for unified session management.
service IdentityService {
  // CreateIdentity creates a new canonical identity.
  rpc CreateIdentity(CreateIdentityRequest) returns (CreateIdentityResponse);

  // GetIdentity retrieves an identity by canonical ID.
  rpc GetIdentity(GetIdentityRequest) returns (GetIdentityResponse);

  // ListIdentities lists all identities.
  rpc ListIdentities(ListIdentitiesRequest) returns (ListIdentitiesResponse);

  // DeleteIdentity deletes an identity and all its links.
  rpc DeleteIdentity(DeleteIdentityRequest) returns (DeleteIdentityResponse);

  // LinkPeer links a platform-specific peer ID to a canonical identity.
  rpc LinkPeer(LinkPeerRequest) returns (LinkPeerResponse);

  // UnlinkPeer removes a peer link from an identity.
  rpc UnlinkPeer(UnlinkPeerRequest) returns (UnlinkPeerResponse);

  // ResolveIdentity resolves a platform peer ID to its canonical identity.
  rpc ResolveIdentity(ResolveIdentityRequest) returns (ResolveIdentityResponse);

  // GetLinkedPeers returns all peer IDs linked to an identity.
  rpc GetLinkedPeers(GetLinkedPeersRequest) returns (GetLinkedPeersResponse);
}

// Identity represents a canonical user identity that can span multiple channels.
message Identity {
  // Canonical identifier (e.g., "user_alice", "user_12345").
  string canonical_id = 1;

  // Display name for the identity.
  string display_name = 2;

  // Email (optional, for matching).
  string email = 3;

  // Linked platform peer IDs (format: "channel:peer_id").
  repeated string linked_peers = 4;

  // Arbitrary metadata.
  map<string, string> metadata = 5;

  // Creation timestamp.
  google.protobuf.Timestamp created_at = 6;

  // Last update timestamp.
  google.protobuf.Timestamp updated_at = 7;
}

message CreateIdentityRequest {
  // Canonical ID (required, must be unique).
  string canonical_id = 1;

  // Display name.
  string display_name = 2;

  // Email (optional).
  string email = 3;

  // Initial linked peers (format: "channel:peer_id").
  repeated string linked_peers = 4;

  // Metadata.
  map<string, string> metadata = 5;
}

message CreateIdentityResponse {
  Identity identity = 1;
}

message GetIdentityRequest {
  string canonical_id = 1;
}

message GetIdentityResponse {
  Identity identity = 1;
}

message ListIdentitiesRequest {
  int32 page_size = 1;
  string page_token = 2;
}

message ListIdentitiesResponse {
  repeated Identity identities = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

message DeleteIdentityRequest {
  string canonical_id = 1;
}

message DeleteIdentityResponse {
  bool success = 1;
}

message LinkPeerRequest {
  // Canonical identity to link to.
  string canonical_id = 1;

  // Channel type (e.g., "telegram", "discord", "slack").
  string channel = 2;

  // Peer ID on the channel.
  string peer_id = 3;
}

message LinkPeerResponse {
  Identity identity = 1;
}

message UnlinkPeerRequest {
  // Canonical identity to unlink from.
  string canonical_id = 1;

  // Channel type.
  string channel = 2;

  // Peer ID.
  string peer_id = 3;
}

message UnlinkPeerResponse {
  Identity identity = 1;
}

message ResolveIdentityRequest {
  // Channel type.
  string channel = 1;

  // Peer ID.
  string peer_id = 2;
}

message ResolveIdentityResponse {
  // True if a linked identity was found.
  bool found = 1;

  // The canonical identity, if found.
  Identity identity = 2;

  // The resolved ID (canonical_id if linked, channel:peer_id if not).
  string resolved_id = 3;
}

message GetLinkedPeersRequest {
  string canonical_id = 1;
}

message GetLinkedPeersResponse {
  // List of linked peer IDs (format: "channel:peer_id").
  repeated string linked_peers = 1;
}

// =============================================================================
// Provisioning Service - Channel Setup Flows
// =============================================================================

// ProvisioningService manages channel provisioning/login flows.
// This provides a generic framework for different channel setup processes
// (QR codes, OAuth, token entry, etc).
service ProvisioningService {
  // StartProvisioning begins a new provisioning session for a channel.
  rpc StartProvisioning(StartProvisioningRequest) returns (StartProvisioningResponse);

  // GetProvisioningStatus retrieves the current status of a provisioning session.
  rpc GetProvisioningStatus(GetProvisioningStatusRequest) returns (GetProvisioningStatusResponse);

  // SubmitProvisioningStep submits data for a provisioning step.
  rpc SubmitProvisioningStep(SubmitProvisioningStepRequest) returns (SubmitProvisioningStepResponse);

  // CancelProvisioning cancels an active provisioning session.
  rpc CancelProvisioning(CancelProvisioningRequest) returns (CancelProvisioningResponse);

  // GetProvisioningRequirements returns the provisioning requirements for a channel type.
  rpc GetProvisioningRequirements(GetProvisioningRequirementsRequest) returns (GetProvisioningRequirementsResponse);
}

// ProvisioningSession represents an active channel provisioning flow.
message ProvisioningSession {
  string id = 1;
  string channel_type = 2;
  ProvisioningStatus status = 3;
  ProvisioningStep current_step = 4;
  repeated ProvisioningStep steps = 5;
  int32 current_step_index = 6;
  string error = 7;
  string edge_id = 8;
  google.protobuf.Timestamp created_at = 9;
  google.protobuf.Timestamp updated_at = 10;
  google.protobuf.Timestamp expires_at = 11;
  map<string, string> data = 12;
}

enum ProvisioningStatus {
  PROVISIONING_STATUS_UNSPECIFIED = 0;
  PROVISIONING_STATUS_PENDING = 1;
  PROVISIONING_STATUS_IN_PROGRESS = 2;
  PROVISIONING_STATUS_COMPLETED = 3;
  PROVISIONING_STATUS_FAILED = 4;
  PROVISIONING_STATUS_CANCELLED = 5;
  PROVISIONING_STATUS_EXPIRED = 6;
}

message ProvisioningStep {
  string id = 1;
  ProvisioningStepType type = 2;
  string title = 3;
  string description = 4;
  ProvisioningStepStatus status = 5;
  map<string, string> data = 6;
  repeated ProvisioningInputField input_fields = 7;
  bool requires_edge = 8;
  int32 timeout_seconds = 9;
}

enum ProvisioningStepType {
  PROVISIONING_STEP_TYPE_UNSPECIFIED = 0;
  PROVISIONING_STEP_TYPE_QR_CODE = 1;
  PROVISIONING_STEP_TYPE_OAUTH = 2;
  PROVISIONING_STEP_TYPE_TOKEN_ENTRY = 3;
  PROVISIONING_STEP_TYPE_PHONE_NUMBER = 4;
  PROVISIONING_STEP_TYPE_VERIFICATION = 5;
  PROVISIONING_STEP_TYPE_CONSENT = 6;
  PROVISIONING_STEP_TYPE_WAIT = 7;
  PROVISIONING_STEP_TYPE_COMPLETE = 8;
}

enum ProvisioningStepStatus {
  PROVISIONING_STEP_STATUS_UNSPECIFIED = 0;
  PROVISIONING_STEP_STATUS_PENDING = 1;
  PROVISIONING_STEP_STATUS_ACTIVE = 2;
  PROVISIONING_STEP_STATUS_COMPLETED = 3;
  PROVISIONING_STEP_STATUS_FAILED = 4;
  PROVISIONING_STEP_STATUS_SKIPPED = 5;
}

message ProvisioningInputField {
  string name = 1;
  string label = 2;
  string type = 3;
  bool required = 4;
  string placeholder = 5;
  string help_text = 6;
  string pattern = 7;
}

message ProvisioningRequirements {
  string channel_type = 1;
  string display_name = 2;
  string description = 3;
  bool requires_edge = 4;
  repeated ProvisioningStep steps = 5;
  string estimated_time = 6;
  string docs_url = 7;
}

message StartProvisioningRequest {
  string channel_type = 1;
  string edge_id = 2;
  map<string, string> config = 3;
}

message StartProvisioningResponse {
  ProvisioningSession session = 1;
}

message GetProvisioningStatusRequest {
  string session_id = 1;
}

message GetProvisioningStatusResponse {
  ProvisioningSession session = 1;
}

message SubmitProvisioningStepRequest {
  string session_id = 1;
  string step_id = 2;
  map<string, string> data = 3;
}

message SubmitProvisioningStepResponse {
  ProvisioningSession session = 1;
}

message CancelProvisioningRequest {
  string session_id = 1;
}

message CancelProvisioningResponse {
  bool success = 1;
}

message GetProvisioningRequirementsRequest {
  string channel_type = 1;
}

message GetProvisioningRequirementsResponse {
  repeated ProvisioningRequirements requirements = 1;
}

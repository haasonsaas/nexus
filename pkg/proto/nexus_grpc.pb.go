// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.28.3
// source: pkg/proto/nexus.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NexusGateway_Stream_FullMethodName = "/nexus.v1.NexusGateway/Stream"
)

// NexusGatewayClient is the client API for NexusGateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// NexusGateway provides real-time bidirectional communication between clients
// and the Nexus AI gateway system.
type NexusGatewayClient interface {
	// Stream establishes a bidirectional streaming connection for real-time
	// message exchange between client and server.
	Stream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ClientMessage, ServerMessage], error)
}

type nexusGatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewNexusGatewayClient(cc grpc.ClientConnInterface) NexusGatewayClient {
	return &nexusGatewayClient{cc}
}

func (c *nexusGatewayClient) Stream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ClientMessage, ServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &NexusGateway_ServiceDesc.Streams[0], NexusGateway_Stream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ClientMessage, ServerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NexusGateway_StreamClient = grpc.BidiStreamingClient[ClientMessage, ServerMessage]

// NexusGatewayServer is the server API for NexusGateway service.
// All implementations must embed UnimplementedNexusGatewayServer
// for forward compatibility.
//
// NexusGateway provides real-time bidirectional communication between clients
// and the Nexus AI gateway system.
type NexusGatewayServer interface {
	// Stream establishes a bidirectional streaming connection for real-time
	// message exchange between client and server.
	Stream(grpc.BidiStreamingServer[ClientMessage, ServerMessage]) error
	mustEmbedUnimplementedNexusGatewayServer()
}

// UnimplementedNexusGatewayServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNexusGatewayServer struct{}

func (UnimplementedNexusGatewayServer) Stream(grpc.BidiStreamingServer[ClientMessage, ServerMessage]) error {
	return status.Error(codes.Unimplemented, "method Stream not implemented")
}
func (UnimplementedNexusGatewayServer) mustEmbedUnimplementedNexusGatewayServer() {}
func (UnimplementedNexusGatewayServer) testEmbeddedByValue()                      {}

// UnsafeNexusGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NexusGatewayServer will
// result in compilation errors.
type UnsafeNexusGatewayServer interface {
	mustEmbedUnimplementedNexusGatewayServer()
}

func RegisterNexusGatewayServer(s grpc.ServiceRegistrar, srv NexusGatewayServer) {
	// If the following call panics, it indicates UnimplementedNexusGatewayServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NexusGateway_ServiceDesc, srv)
}

func _NexusGateway_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NexusGatewayServer).Stream(&grpc.GenericServerStream[ClientMessage, ServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NexusGateway_StreamServer = grpc.BidiStreamingServer[ClientMessage, ServerMessage]

// NexusGateway_ServiceDesc is the grpc.ServiceDesc for NexusGateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NexusGateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.NexusGateway",
	HandlerType: (*NexusGatewayServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _NexusGateway_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	SessionService_CreateSession_FullMethodName = "/nexus.v1.SessionService/CreateSession"
	SessionService_GetSession_FullMethodName    = "/nexus.v1.SessionService/GetSession"
	SessionService_ListSessions_FullMethodName  = "/nexus.v1.SessionService/ListSessions"
	SessionService_DeleteSession_FullMethodName = "/nexus.v1.SessionService/DeleteSession"
	SessionService_UpdateSession_FullMethodName = "/nexus.v1.SessionService/UpdateSession"
)

// SessionServiceClient is the client API for SessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SessionService manages conversation sessions.
type SessionServiceClient interface {
	// CreateSession creates a new conversation session.
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error)
	// GetSession retrieves a session by ID.
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error)
	// ListSessions lists sessions with optional filtering.
	ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	// DeleteSession deletes a session and its messages.
	DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error)
	// UpdateSession updates session metadata.
	UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*UpdateSessionResponse, error)
}

type sessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionServiceClient(cc grpc.ClientConnInterface) SessionServiceClient {
	return &sessionServiceClient{cc}
}

func (c *sessionServiceClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, SessionService_ListSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_DeleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*UpdateSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_UpdateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionServiceServer is the server API for SessionService service.
// All implementations must embed UnimplementedSessionServiceServer
// for forward compatibility.
//
// SessionService manages conversation sessions.
type SessionServiceServer interface {
	// CreateSession creates a new conversation session.
	CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error)
	// GetSession retrieves a session by ID.
	GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error)
	// ListSessions lists sessions with optional filtering.
	ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	// DeleteSession deletes a session and its messages.
	DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error)
	// UpdateSession updates session metadata.
	UpdateSession(context.Context, *UpdateSessionRequest) (*UpdateSessionResponse, error)
	mustEmbedUnimplementedSessionServiceServer()
}

// UnimplementedSessionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionServiceServer struct{}

func (UnimplementedSessionServiceServer) CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedSessionServiceServer) GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedSessionServiceServer) ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSessions not implemented")
}
func (UnimplementedSessionServiceServer) DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedSessionServiceServer) UpdateSession(context.Context, *UpdateSessionRequest) (*UpdateSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSession not implemented")
}
func (UnimplementedSessionServiceServer) mustEmbedUnimplementedSessionServiceServer() {}
func (UnimplementedSessionServiceServer) testEmbeddedByValue()                        {}

// UnsafeSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServiceServer will
// result in compilation errors.
type UnsafeSessionServiceServer interface {
	mustEmbedUnimplementedSessionServiceServer()
}

func RegisterSessionServiceServer(s grpc.ServiceRegistrar, srv SessionServiceServer) {
	// If the following call panics, it indicates UnimplementedSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionService_ServiceDesc, srv)
}

func _SessionService_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_ListSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).ListSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).DeleteSession(ctx, req.(*DeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_UpdateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).UpdateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_UpdateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).UpdateSession(ctx, req.(*UpdateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionService_ServiceDesc is the grpc.ServiceDesc for SessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.SessionService",
	HandlerType: (*SessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSession",
			Handler:    _SessionService_CreateSession_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _SessionService_GetSession_Handler,
		},
		{
			MethodName: "ListSessions",
			Handler:    _SessionService_ListSessions_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _SessionService_DeleteSession_Handler,
		},
		{
			MethodName: "UpdateSession",
			Handler:    _SessionService_UpdateSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	AgentService_CreateAgent_FullMethodName = "/nexus.v1.AgentService/CreateAgent"
	AgentService_GetAgent_FullMethodName    = "/nexus.v1.AgentService/GetAgent"
	AgentService_ListAgents_FullMethodName  = "/nexus.v1.AgentService/ListAgents"
	AgentService_UpdateAgent_FullMethodName = "/nexus.v1.AgentService/UpdateAgent"
	AgentService_DeleteAgent_FullMethodName = "/nexus.v1.AgentService/DeleteAgent"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AgentService manages AI agents.
type AgentServiceClient interface {
	// CreateAgent creates a new agent configuration.
	CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*CreateAgentResponse, error)
	// GetAgent retrieves an agent by ID.
	GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*GetAgentResponse, error)
	// ListAgents lists agents for a user.
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	// UpdateAgent updates an agent configuration.
	UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*UpdateAgentResponse, error)
	// DeleteAgent deletes an agent.
	DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*CreateAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAgentResponse)
	err := c.cc.Invoke(ctx, AgentService_CreateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*GetAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentResponse)
	err := c.cc.Invoke(ctx, AgentService_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, AgentService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*UpdateAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAgentResponse)
	err := c.cc.Invoke(ctx, AgentService_UpdateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAgentResponse)
	err := c.cc.Invoke(ctx, AgentService_DeleteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
//
// AgentService manages AI agents.
type AgentServiceServer interface {
	// CreateAgent creates a new agent configuration.
	CreateAgent(context.Context, *CreateAgentRequest) (*CreateAgentResponse, error)
	// GetAgent retrieves an agent by ID.
	GetAgent(context.Context, *GetAgentRequest) (*GetAgentResponse, error)
	// ListAgents lists agents for a user.
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	// UpdateAgent updates an agent configuration.
	UpdateAgent(context.Context, *UpdateAgentRequest) (*UpdateAgentResponse, error)
	// DeleteAgent deletes an agent.
	DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) CreateAgent(context.Context, *CreateAgentRequest) (*CreateAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAgent not implemented")
}
func (UnimplementedAgentServiceServer) GetAgent(context.Context, *GetAgentRequest) (*GetAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedAgentServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedAgentServiceServer) UpdateAgent(context.Context, *UpdateAgentRequest) (*UpdateAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateAgent not implemented")
}
func (UnimplementedAgentServiceServer) DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteAgent not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call panics, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_CreateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).CreateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_CreateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).CreateAgent(ctx, req.(*CreateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgent(ctx, req.(*GetAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_UpdateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).UpdateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_UpdateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).UpdateAgent(ctx, req.(*UpdateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_DeleteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).DeleteAgent(ctx, req.(*DeleteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAgent",
			Handler:    _AgentService_CreateAgent_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _AgentService_GetAgent_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _AgentService_ListAgents_Handler,
		},
		{
			MethodName: "UpdateAgent",
			Handler:    _AgentService_UpdateAgent_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _AgentService_DeleteAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	ChannelService_ConnectChannel_FullMethodName    = "/nexus.v1.ChannelService/ConnectChannel"
	ChannelService_DisconnectChannel_FullMethodName = "/nexus.v1.ChannelService/DisconnectChannel"
	ChannelService_GetChannelStatus_FullMethodName  = "/nexus.v1.ChannelService/GetChannelStatus"
	ChannelService_ListChannels_FullMethodName      = "/nexus.v1.ChannelService/ListChannels"
)

// ChannelServiceClient is the client API for ChannelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ChannelService manages channel connections.
type ChannelServiceClient interface {
	// ConnectChannel establishes a connection to a messaging platform.
	ConnectChannel(ctx context.Context, in *ConnectChannelRequest, opts ...grpc.CallOption) (*ConnectChannelResponse, error)
	// DisconnectChannel disconnects from a messaging platform.
	DisconnectChannel(ctx context.Context, in *DisconnectChannelRequest, opts ...grpc.CallOption) (*DisconnectChannelResponse, error)
	// GetChannelStatus retrieves the status of a channel connection.
	GetChannelStatus(ctx context.Context, in *GetChannelStatusRequest, opts ...grpc.CallOption) (*GetChannelStatusResponse, error)
	// ListChannels lists all configured channels.
	ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error)
}

type channelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChannelServiceClient(cc grpc.ClientConnInterface) ChannelServiceClient {
	return &channelServiceClient{cc}
}

func (c *channelServiceClient) ConnectChannel(ctx context.Context, in *ConnectChannelRequest, opts ...grpc.CallOption) (*ConnectChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectChannelResponse)
	err := c.cc.Invoke(ctx, ChannelService_ConnectChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) DisconnectChannel(ctx context.Context, in *DisconnectChannelRequest, opts ...grpc.CallOption) (*DisconnectChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectChannelResponse)
	err := c.cc.Invoke(ctx, ChannelService_DisconnectChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) GetChannelStatus(ctx context.Context, in *GetChannelStatusRequest, opts ...grpc.CallOption) (*GetChannelStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChannelStatusResponse)
	err := c.cc.Invoke(ctx, ChannelService_GetChannelStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListChannelsResponse)
	err := c.cc.Invoke(ctx, ChannelService_ListChannels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelServiceServer is the server API for ChannelService service.
// All implementations must embed UnimplementedChannelServiceServer
// for forward compatibility.
//
// ChannelService manages channel connections.
type ChannelServiceServer interface {
	// ConnectChannel establishes a connection to a messaging platform.
	ConnectChannel(context.Context, *ConnectChannelRequest) (*ConnectChannelResponse, error)
	// DisconnectChannel disconnects from a messaging platform.
	DisconnectChannel(context.Context, *DisconnectChannelRequest) (*DisconnectChannelResponse, error)
	// GetChannelStatus retrieves the status of a channel connection.
	GetChannelStatus(context.Context, *GetChannelStatusRequest) (*GetChannelStatusResponse, error)
	// ListChannels lists all configured channels.
	ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error)
	mustEmbedUnimplementedChannelServiceServer()
}

// UnimplementedChannelServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChannelServiceServer struct{}

func (UnimplementedChannelServiceServer) ConnectChannel(context.Context, *ConnectChannelRequest) (*ConnectChannelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConnectChannel not implemented")
}
func (UnimplementedChannelServiceServer) DisconnectChannel(context.Context, *DisconnectChannelRequest) (*DisconnectChannelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisconnectChannel not implemented")
}
func (UnimplementedChannelServiceServer) GetChannelStatus(context.Context, *GetChannelStatusRequest) (*GetChannelStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChannelStatus not implemented")
}
func (UnimplementedChannelServiceServer) ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListChannels not implemented")
}
func (UnimplementedChannelServiceServer) mustEmbedUnimplementedChannelServiceServer() {}
func (UnimplementedChannelServiceServer) testEmbeddedByValue()                        {}

// UnsafeChannelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChannelServiceServer will
// result in compilation errors.
type UnsafeChannelServiceServer interface {
	mustEmbedUnimplementedChannelServiceServer()
}

func RegisterChannelServiceServer(s grpc.ServiceRegistrar, srv ChannelServiceServer) {
	// If the following call panics, it indicates UnimplementedChannelServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChannelService_ServiceDesc, srv)
}

func _ChannelService_ConnectChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).ConnectChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelService_ConnectChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).ConnectChannel(ctx, req.(*ConnectChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_DisconnectChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).DisconnectChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelService_DisconnectChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).DisconnectChannel(ctx, req.(*DisconnectChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_GetChannelStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).GetChannelStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelService_GetChannelStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).GetChannelStatus(ctx, req.(*GetChannelStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).ListChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelService_ListChannels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).ListChannels(ctx, req.(*ListChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChannelService_ServiceDesc is the grpc.ServiceDesc for ChannelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChannelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.ChannelService",
	HandlerType: (*ChannelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConnectChannel",
			Handler:    _ChannelService_ConnectChannel_Handler,
		},
		{
			MethodName: "DisconnectChannel",
			Handler:    _ChannelService_DisconnectChannel_Handler,
		},
		{
			MethodName: "GetChannelStatus",
			Handler:    _ChannelService_GetChannelStatus_Handler,
		},
		{
			MethodName: "ListChannels",
			Handler:    _ChannelService_ListChannels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	HealthService_Check_FullMethodName = "/nexus.v1.HealthService/Check"
	HealthService_Watch_FullMethodName = "/nexus.v1.HealthService/Watch"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// HealthService provides health check functionality.
type HealthServiceClient interface {
	// Check performs a health check.
	Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// Watch performs a streaming health check.
	Watch(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthCheckResponse], error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_Check_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) Watch(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthCheckResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[0], HealthService_Watch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HealthCheckRequest, HealthCheckResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_WatchClient = grpc.ServerStreamingClient[HealthCheckResponse]

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
//
// HealthService provides health check functionality.
type HealthServiceServer interface {
	// Check performs a health check.
	Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// Watch performs a streaming health check.
	Watch(*HealthCheckRequest, grpc.ServerStreamingServer[HealthCheckResponse]) error
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedHealthServiceServer) Watch(*HealthCheckRequest, grpc.ServerStreamingServer[HealthCheckResponse]) error {
	return status.Error(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call panics, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Check(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HealthCheckRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HealthServiceServer).Watch(m, &grpc.GenericServerStream[HealthCheckRequest, HealthCheckResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_WatchServer = grpc.ServerStreamingServer[HealthCheckResponse]

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _HealthService_Check_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _HealthService_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	NodeService_CreatePairingToken_FullMethodName = "/nexus.v1.NodeService/CreatePairingToken"
	NodeService_ListNodes_FullMethodName          = "/nexus.v1.NodeService/ListNodes"
	NodeService_GetNode_FullMethodName            = "/nexus.v1.NodeService/GetNode"
	NodeService_UpdateNode_FullMethodName         = "/nexus.v1.NodeService/UpdateNode"
	NodeService_RevokeNode_FullMethodName         = "/nexus.v1.NodeService/RevokeNode"
	NodeService_DeleteNode_FullMethodName         = "/nexus.v1.NodeService/DeleteNode"
	NodeService_RequestAction_FullMethodName      = "/nexus.v1.NodeService/RequestAction"
	NodeService_GetNodeAuditLogs_FullMethodName   = "/nexus.v1.NodeService/GetNodeAuditLogs"
)

// NodeServiceClient is the client API for NodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// NodeService manages device nodes (Mac, iPhone, etc.) for privileged actions.
type NodeServiceClient interface {
	// CreatePairingToken generates a token for pairing a new node.
	CreatePairingToken(ctx context.Context, in *CreatePairingTokenRequest, opts ...grpc.CallOption) (*CreatePairingTokenResponse, error)
	// ListNodes returns all registered nodes.
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
	// GetNode retrieves a specific node.
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error)
	// UpdateNode updates a node's configuration.
	UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*UpdateNodeResponse, error)
	// RevokeNode revokes a node's access.
	RevokeNode(ctx context.Context, in *RevokeNodeRequest, opts ...grpc.CallOption) (*RevokeNodeResponse, error)
	// DeleteNode permanently removes a node.
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error)
	// RequestAction requests an action on a node (camera, screen, etc.).
	RequestAction(ctx context.Context, in *RequestActionRequest, opts ...grpc.CallOption) (*RequestActionResponse, error)
	// GetNodeAuditLogs retrieves audit logs for a node.
	GetNodeAuditLogs(ctx context.Context, in *GetNodeAuditLogsRequest, opts ...grpc.CallOption) (*GetNodeAuditLogsResponse, error)
}

type nodeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeServiceClient(cc grpc.ClientConnInterface) NodeServiceClient {
	return &nodeServiceClient{cc}
}

func (c *nodeServiceClient) CreatePairingToken(ctx context.Context, in *CreatePairingTokenRequest, opts ...grpc.CallOption) (*CreatePairingTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePairingTokenResponse)
	err := c.cc.Invoke(ctx, NodeService_CreatePairingToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodesResponse)
	err := c.cc.Invoke(ctx, NodeService_ListNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeResponse)
	err := c.cc.Invoke(ctx, NodeService_GetNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*UpdateNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateNodeResponse)
	err := c.cc.Invoke(ctx, NodeService_UpdateNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) RevokeNode(ctx context.Context, in *RevokeNodeRequest, opts ...grpc.CallOption) (*RevokeNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeNodeResponse)
	err := c.cc.Invoke(ctx, NodeService_RevokeNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteNodeResponse)
	err := c.cc.Invoke(ctx, NodeService_DeleteNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) RequestAction(ctx context.Context, in *RequestActionRequest, opts ...grpc.CallOption) (*RequestActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestActionResponse)
	err := c.cc.Invoke(ctx, NodeService_RequestAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetNodeAuditLogs(ctx context.Context, in *GetNodeAuditLogsRequest, opts ...grpc.CallOption) (*GetNodeAuditLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeAuditLogsResponse)
	err := c.cc.Invoke(ctx, NodeService_GetNodeAuditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServiceServer is the server API for NodeService service.
// All implementations must embed UnimplementedNodeServiceServer
// for forward compatibility.
//
// NodeService manages device nodes (Mac, iPhone, etc.) for privileged actions.
type NodeServiceServer interface {
	// CreatePairingToken generates a token for pairing a new node.
	CreatePairingToken(context.Context, *CreatePairingTokenRequest) (*CreatePairingTokenResponse, error)
	// ListNodes returns all registered nodes.
	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
	// GetNode retrieves a specific node.
	GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error)
	// UpdateNode updates a node's configuration.
	UpdateNode(context.Context, *UpdateNodeRequest) (*UpdateNodeResponse, error)
	// RevokeNode revokes a node's access.
	RevokeNode(context.Context, *RevokeNodeRequest) (*RevokeNodeResponse, error)
	// DeleteNode permanently removes a node.
	DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error)
	// RequestAction requests an action on a node (camera, screen, etc.).
	RequestAction(context.Context, *RequestActionRequest) (*RequestActionResponse, error)
	// GetNodeAuditLogs retrieves audit logs for a node.
	GetNodeAuditLogs(context.Context, *GetNodeAuditLogsRequest) (*GetNodeAuditLogsResponse, error)
	mustEmbedUnimplementedNodeServiceServer()
}

// UnimplementedNodeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeServiceServer struct{}

func (UnimplementedNodeServiceServer) CreatePairingToken(context.Context, *CreatePairingTokenRequest) (*CreatePairingTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePairingToken not implemented")
}
func (UnimplementedNodeServiceServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedNodeServiceServer) GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedNodeServiceServer) UpdateNode(context.Context, *UpdateNodeRequest) (*UpdateNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateNode not implemented")
}
func (UnimplementedNodeServiceServer) RevokeNode(context.Context, *RevokeNodeRequest) (*RevokeNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeNode not implemented")
}
func (UnimplementedNodeServiceServer) DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteNode not implemented")
}
func (UnimplementedNodeServiceServer) RequestAction(context.Context, *RequestActionRequest) (*RequestActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestAction not implemented")
}
func (UnimplementedNodeServiceServer) GetNodeAuditLogs(context.Context, *GetNodeAuditLogsRequest) (*GetNodeAuditLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeAuditLogs not implemented")
}
func (UnimplementedNodeServiceServer) mustEmbedUnimplementedNodeServiceServer() {}
func (UnimplementedNodeServiceServer) testEmbeddedByValue()                     {}

// UnsafeNodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServiceServer will
// result in compilation errors.
type UnsafeNodeServiceServer interface {
	mustEmbedUnimplementedNodeServiceServer()
}

func RegisterNodeServiceServer(s grpc.ServiceRegistrar, srv NodeServiceServer) {
	// If the following call panics, it indicates UnimplementedNodeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeService_ServiceDesc, srv)
}

func _NodeService_CreatePairingToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePairingTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).CreatePairingToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_CreatePairingToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).CreatePairingToken(ctx, req.(*CreatePairingTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).ListNodes(ctx, req.(*ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_GetNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_UpdateNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).UpdateNode(ctx, req.(*UpdateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_RevokeNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).RevokeNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_RevokeNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).RevokeNode(ctx, req.(*RevokeNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_DeleteNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).DeleteNode(ctx, req.(*DeleteNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_RequestAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).RequestAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_RequestAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).RequestAction(ctx, req.(*RequestActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetNodeAuditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeAuditLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetNodeAuditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_GetNodeAuditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetNodeAuditLogs(ctx, req.(*GetNodeAuditLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeService_ServiceDesc is the grpc.ServiceDesc for NodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.NodeService",
	HandlerType: (*NodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePairingToken",
			Handler:    _NodeService_CreatePairingToken_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _NodeService_ListNodes_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _NodeService_GetNode_Handler,
		},
		{
			MethodName: "UpdateNode",
			Handler:    _NodeService_UpdateNode_Handler,
		},
		{
			MethodName: "RevokeNode",
			Handler:    _NodeService_RevokeNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _NodeService_DeleteNode_Handler,
		},
		{
			MethodName: "RequestAction",
			Handler:    _NodeService_RequestAction_Handler,
		},
		{
			MethodName: "GetNodeAuditLogs",
			Handler:    _NodeService_GetNodeAuditLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	EdgeService_Connect_FullMethodName       = "/nexus.v1.EdgeService/Connect"
	EdgeService_GetEdgeStatus_FullMethodName = "/nexus.v1.EdgeService/GetEdgeStatus"
	EdgeService_ListEdges_FullMethodName     = "/nexus.v1.EdgeService/ListEdges"
)

// EdgeServiceClient is the client API for EdgeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EdgeService manages edge daemon connections and tool execution.
// Edge daemons connect from user machines to provide local capabilities
// like device access, browser relay, and edge-only channels.
type EdgeServiceClient interface {
	// Connect establishes a bidirectional stream between edge and core.
	// The edge sends registration, heartbeats, and tool results.
	// The core sends tool execution requests and control messages.
	Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[EdgeMessage, CoreMessage], error)
	// GetEdgeStatus returns the status of a connected edge.
	GetEdgeStatus(ctx context.Context, in *GetEdgeStatusRequest, opts ...grpc.CallOption) (*GetEdgeStatusResponse, error)
	// ListEdges returns all connected edges.
	ListEdges(ctx context.Context, in *ListEdgesRequest, opts ...grpc.CallOption) (*ListEdgesResponse, error)
}

type edgeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEdgeServiceClient(cc grpc.ClientConnInterface) EdgeServiceClient {
	return &edgeServiceClient{cc}
}

func (c *edgeServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[EdgeMessage, CoreMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EdgeService_ServiceDesc.Streams[0], EdgeService_Connect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[EdgeMessage, CoreMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EdgeService_ConnectClient = grpc.BidiStreamingClient[EdgeMessage, CoreMessage]

func (c *edgeServiceClient) GetEdgeStatus(ctx context.Context, in *GetEdgeStatusRequest, opts ...grpc.CallOption) (*GetEdgeStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEdgeStatusResponse)
	err := c.cc.Invoke(ctx, EdgeService_GetEdgeStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *edgeServiceClient) ListEdges(ctx context.Context, in *ListEdgesRequest, opts ...grpc.CallOption) (*ListEdgesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEdgesResponse)
	err := c.cc.Invoke(ctx, EdgeService_ListEdges_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EdgeServiceServer is the server API for EdgeService service.
// All implementations must embed UnimplementedEdgeServiceServer
// for forward compatibility.
//
// EdgeService manages edge daemon connections and tool execution.
// Edge daemons connect from user machines to provide local capabilities
// like device access, browser relay, and edge-only channels.
type EdgeServiceServer interface {
	// Connect establishes a bidirectional stream between edge and core.
	// The edge sends registration, heartbeats, and tool results.
	// The core sends tool execution requests and control messages.
	Connect(grpc.BidiStreamingServer[EdgeMessage, CoreMessage]) error
	// GetEdgeStatus returns the status of a connected edge.
	GetEdgeStatus(context.Context, *GetEdgeStatusRequest) (*GetEdgeStatusResponse, error)
	// ListEdges returns all connected edges.
	ListEdges(context.Context, *ListEdgesRequest) (*ListEdgesResponse, error)
	mustEmbedUnimplementedEdgeServiceServer()
}

// UnimplementedEdgeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEdgeServiceServer struct{}

func (UnimplementedEdgeServiceServer) Connect(grpc.BidiStreamingServer[EdgeMessage, CoreMessage]) error {
	return status.Error(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedEdgeServiceServer) GetEdgeStatus(context.Context, *GetEdgeStatusRequest) (*GetEdgeStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEdgeStatus not implemented")
}
func (UnimplementedEdgeServiceServer) ListEdges(context.Context, *ListEdgesRequest) (*ListEdgesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEdges not implemented")
}
func (UnimplementedEdgeServiceServer) mustEmbedUnimplementedEdgeServiceServer() {}
func (UnimplementedEdgeServiceServer) testEmbeddedByValue()                     {}

// UnsafeEdgeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EdgeServiceServer will
// result in compilation errors.
type UnsafeEdgeServiceServer interface {
	mustEmbedUnimplementedEdgeServiceServer()
}

func RegisterEdgeServiceServer(s grpc.ServiceRegistrar, srv EdgeServiceServer) {
	// If the following call panics, it indicates UnimplementedEdgeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EdgeService_ServiceDesc, srv)
}

func _EdgeService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EdgeServiceServer).Connect(&grpc.GenericServerStream[EdgeMessage, CoreMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EdgeService_ConnectServer = grpc.BidiStreamingServer[EdgeMessage, CoreMessage]

func _EdgeService_GetEdgeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEdgeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EdgeServiceServer).GetEdgeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EdgeService_GetEdgeStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EdgeServiceServer).GetEdgeStatus(ctx, req.(*GetEdgeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EdgeService_ListEdges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEdgesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EdgeServiceServer).ListEdges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EdgeService_ListEdges_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EdgeServiceServer).ListEdges(ctx, req.(*ListEdgesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EdgeService_ServiceDesc is the grpc.ServiceDesc for EdgeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EdgeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.EdgeService",
	HandlerType: (*EdgeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEdgeStatus",
			Handler:    _EdgeService_GetEdgeStatus_Handler,
		},
		{
			MethodName: "ListEdges",
			Handler:    _EdgeService_ListEdges_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _EdgeService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	EventService_GetEvents_FullMethodName   = "/nexus.v1.EventService/GetEvents"
	EventService_GetTimeline_FullMethodName = "/nexus.v1.EventService/GetTimeline"
)

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EventService provides access to the event timeline for debugging.
type EventServiceClient interface {
	// GetEvents retrieves events by run ID or session ID.
	GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (*GetEventsResponse, error)
	// GetTimeline retrieves a formatted timeline for a run.
	GetTimeline(ctx context.Context, in *GetTimelineRequest, opts ...grpc.CallOption) (*GetTimelineResponse, error)
}

type eventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventServiceClient(cc grpc.ClientConnInterface) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (*GetEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEventsResponse)
	err := c.cc.Invoke(ctx, EventService_GetEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetTimeline(ctx context.Context, in *GetTimelineRequest, opts ...grpc.CallOption) (*GetTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTimelineResponse)
	err := c.cc.Invoke(ctx, EventService_GetTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventServiceServer is the server API for EventService service.
// All implementations must embed UnimplementedEventServiceServer
// for forward compatibility.
//
// EventService provides access to the event timeline for debugging.
type EventServiceServer interface {
	// GetEvents retrieves events by run ID or session ID.
	GetEvents(context.Context, *GetEventsRequest) (*GetEventsResponse, error)
	// GetTimeline retrieves a formatted timeline for a run.
	GetTimeline(context.Context, *GetTimelineRequest) (*GetTimelineResponse, error)
	mustEmbedUnimplementedEventServiceServer()
}

// UnimplementedEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventServiceServer struct{}

func (UnimplementedEventServiceServer) GetEvents(context.Context, *GetEventsRequest) (*GetEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEvents not implemented")
}
func (UnimplementedEventServiceServer) GetTimeline(context.Context, *GetTimelineRequest) (*GetTimelineResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTimeline not implemented")
}
func (UnimplementedEventServiceServer) mustEmbedUnimplementedEventServiceServer() {}
func (UnimplementedEventServiceServer) testEmbeddedByValue()                      {}

// UnsafeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServiceServer will
// result in compilation errors.
type UnsafeEventServiceServer interface {
	mustEmbedUnimplementedEventServiceServer()
}

func RegisterEventServiceServer(s grpc.ServiceRegistrar, srv EventServiceServer) {
	// If the following call panics, it indicates UnimplementedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EventService_ServiceDesc, srv)
}

func _EventService_GetEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetEvents(ctx, req.(*GetEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetTimeline(ctx, req.(*GetTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventService_ServiceDesc is the grpc.ServiceDesc for EventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEvents",
			Handler:    _EventService_GetEvents_Handler,
		},
		{
			MethodName: "GetTimeline",
			Handler:    _EventService_GetTimeline_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	TaskService_CreateTask_FullMethodName     = "/nexus.v1.TaskService/CreateTask"
	TaskService_GetTask_FullMethodName        = "/nexus.v1.TaskService/GetTask"
	TaskService_ListTasks_FullMethodName      = "/nexus.v1.TaskService/ListTasks"
	TaskService_UpdateTask_FullMethodName     = "/nexus.v1.TaskService/UpdateTask"
	TaskService_DeleteTask_FullMethodName     = "/nexus.v1.TaskService/DeleteTask"
	TaskService_PauseTask_FullMethodName      = "/nexus.v1.TaskService/PauseTask"
	TaskService_ResumeTask_FullMethodName     = "/nexus.v1.TaskService/ResumeTask"
	TaskService_TriggerTask_FullMethodName    = "/nexus.v1.TaskService/TriggerTask"
	TaskService_ListExecutions_FullMethodName = "/nexus.v1.TaskService/ListExecutions"
)

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TaskService manages scheduled tasks for proactive messaging and automation.
type TaskServiceClient interface {
	// CreateTask creates a new scheduled task.
	CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error)
	// GetTask retrieves a task by ID.
	GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error)
	// ListTasks lists tasks with optional filtering.
	ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
	// UpdateTask updates an existing task.
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error)
	// DeleteTask deletes a task.
	DeleteTask(ctx context.Context, in *DeleteTaskRequest, opts ...grpc.CallOption) (*DeleteTaskResponse, error)
	// PauseTask pauses a task's schedule.
	PauseTask(ctx context.Context, in *PauseTaskRequest, opts ...grpc.CallOption) (*PauseTaskResponse, error)
	// ResumeTask resumes a paused task.
	ResumeTask(ctx context.Context, in *ResumeTaskRequest, opts ...grpc.CallOption) (*ResumeTaskResponse, error)
	// TriggerTask manually triggers a task to run immediately.
	TriggerTask(ctx context.Context, in *TriggerTaskRequest, opts ...grpc.CallOption) (*TriggerTaskResponse, error)
	// ListExecutions lists executions for a task.
	ListExecutions(ctx context.Context, in *ListExecutionsRequest, opts ...grpc.CallOption) (*ListExecutionsResponse, error)
}

type taskServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_CreateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_GetTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTasksResponse)
	err := c.cc.Invoke(ctx, TaskService_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_UpdateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) DeleteTask(ctx context.Context, in *DeleteTaskRequest, opts ...grpc.CallOption) (*DeleteTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_DeleteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) PauseTask(ctx context.Context, in *PauseTaskRequest, opts ...grpc.CallOption) (*PauseTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_PauseTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ResumeTask(ctx context.Context, in *ResumeTaskRequest, opts ...grpc.CallOption) (*ResumeTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_ResumeTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) TriggerTask(ctx context.Context, in *TriggerTaskRequest, opts ...grpc.CallOption) (*TriggerTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_TriggerTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ListExecutions(ctx context.Context, in *ListExecutionsRequest, opts ...grpc.CallOption) (*ListExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExecutionsResponse)
	err := c.cc.Invoke(ctx, TaskService_ListExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility.
//
// TaskService manages scheduled tasks for proactive messaging and automation.
type TaskServiceServer interface {
	// CreateTask creates a new scheduled task.
	CreateTask(context.Context, *CreateTaskRequest) (*CreateTaskResponse, error)
	// GetTask retrieves a task by ID.
	GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error)
	// ListTasks lists tasks with optional filtering.
	ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
	// UpdateTask updates an existing task.
	UpdateTask(context.Context, *UpdateTaskRequest) (*UpdateTaskResponse, error)
	// DeleteTask deletes a task.
	DeleteTask(context.Context, *DeleteTaskRequest) (*DeleteTaskResponse, error)
	// PauseTask pauses a task's schedule.
	PauseTask(context.Context, *PauseTaskRequest) (*PauseTaskResponse, error)
	// ResumeTask resumes a paused task.
	ResumeTask(context.Context, *ResumeTaskRequest) (*ResumeTaskResponse, error)
	// TriggerTask manually triggers a task to run immediately.
	TriggerTask(context.Context, *TriggerTaskRequest) (*TriggerTaskResponse, error)
	// ListExecutions lists executions for a task.
	ListExecutions(context.Context, *ListExecutionsRequest) (*ListExecutionsResponse, error)
	mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskServiceServer struct{}

func (UnimplementedTaskServiceServer) CreateTask(context.Context, *CreateTaskRequest) (*CreateTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTask not implemented")
}
func (UnimplementedTaskServiceServer) GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTask not implemented")
}
func (UnimplementedTaskServiceServer) ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedTaskServiceServer) UpdateTask(context.Context, *UpdateTaskRequest) (*UpdateTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTask not implemented")
}
func (UnimplementedTaskServiceServer) DeleteTask(context.Context, *DeleteTaskRequest) (*DeleteTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTask not implemented")
}
func (UnimplementedTaskServiceServer) PauseTask(context.Context, *PauseTaskRequest) (*PauseTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseTask not implemented")
}
func (UnimplementedTaskServiceServer) ResumeTask(context.Context, *ResumeTaskRequest) (*ResumeTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeTask not implemented")
}
func (UnimplementedTaskServiceServer) TriggerTask(context.Context, *TriggerTaskRequest) (*TriggerTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TriggerTask not implemented")
}
func (UnimplementedTaskServiceServer) ListExecutions(context.Context, *ListExecutionsRequest) (*ListExecutionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListExecutions not implemented")
}
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {}
func (UnimplementedTaskServiceServer) testEmbeddedByValue()                     {}

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
	mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) {
	// If the following call panics, it indicates UnimplementedTaskServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskService_ServiceDesc, srv)
}

func _TaskService_CreateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).CreateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_CreateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).CreateTask(ctx, req.(*CreateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_GetTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetTask(ctx, req.(*GetTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ListTasks(ctx, req.(*ListTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_UpdateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_DeleteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).DeleteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_DeleteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).DeleteTask(ctx, req.(*DeleteTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_PauseTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).PauseTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_PauseTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).PauseTask(ctx, req.(*PauseTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ResumeTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ResumeTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_ResumeTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ResumeTask(ctx, req.(*ResumeTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_TriggerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).TriggerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_TriggerTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).TriggerTask(ctx, req.(*TriggerTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ListExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ListExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_ListExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ListExecutions(ctx, req.(*ListExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTask",
			Handler:    _TaskService_CreateTask_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _TaskService_GetTask_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _TaskService_ListTasks_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _TaskService_UpdateTask_Handler,
		},
		{
			MethodName: "DeleteTask",
			Handler:    _TaskService_DeleteTask_Handler,
		},
		{
			MethodName: "PauseTask",
			Handler:    _TaskService_PauseTask_Handler,
		},
		{
			MethodName: "ResumeTask",
			Handler:    _TaskService_ResumeTask_Handler,
		},
		{
			MethodName: "TriggerTask",
			Handler:    _TaskService_TriggerTask_Handler,
		},
		{
			MethodName: "ListExecutions",
			Handler:    _TaskService_ListExecutions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	MessageService_SendMessage_FullMethodName      = "/nexus.v1.MessageService/SendMessage"
	MessageService_BroadcastMessage_FullMethodName = "/nexus.v1.MessageService/BroadcastMessage"
)

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MessageService provides proactive message sending capabilities.
type MessageServiceClient interface {
	// SendMessage sends a message to a specific channel/peer without requiring an inbound message.
	SendMessage(ctx context.Context, in *ProactiveSendRequest, opts ...grpc.CallOption) (*ProactiveSendResponse, error)
	// BroadcastMessage sends a message to multiple recipients.
	BroadcastMessage(ctx context.Context, in *BroadcastMessageRequest, opts ...grpc.CallOption) (*BroadcastMessageResponse, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) SendMessage(ctx context.Context, in *ProactiveSendRequest, opts ...grpc.CallOption) (*ProactiveSendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProactiveSendResponse)
	err := c.cc.Invoke(ctx, MessageService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) BroadcastMessage(ctx context.Context, in *BroadcastMessageRequest, opts ...grpc.CallOption) (*BroadcastMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BroadcastMessageResponse)
	err := c.cc.Invoke(ctx, MessageService_BroadcastMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility.
//
// MessageService provides proactive message sending capabilities.
type MessageServiceServer interface {
	// SendMessage sends a message to a specific channel/peer without requiring an inbound message.
	SendMessage(context.Context, *ProactiveSendRequest) (*ProactiveSendResponse, error)
	// BroadcastMessage sends a message to multiple recipients.
	BroadcastMessage(context.Context, *BroadcastMessageRequest) (*BroadcastMessageResponse, error)
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageServiceServer struct{}

func (UnimplementedMessageServiceServer) SendMessage(context.Context, *ProactiveSendRequest) (*ProactiveSendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedMessageServiceServer) BroadcastMessage(context.Context, *BroadcastMessageRequest) (*BroadcastMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BroadcastMessage not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}
func (UnimplementedMessageServiceServer) testEmbeddedByValue()                        {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	// If the following call panics, it indicates UnimplementedMessageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProactiveSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).SendMessage(ctx, req.(*ProactiveSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_BroadcastMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).BroadcastMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_BroadcastMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).BroadcastMessage(ctx, req.(*BroadcastMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _MessageService_SendMessage_Handler,
		},
		{
			MethodName: "BroadcastMessage",
			Handler:    _MessageService_BroadcastMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}

const (
	IdentityService_CreateIdentity_FullMethodName  = "/nexus.v1.IdentityService/CreateIdentity"
	IdentityService_GetIdentity_FullMethodName     = "/nexus.v1.IdentityService/GetIdentity"
	IdentityService_ListIdentities_FullMethodName  = "/nexus.v1.IdentityService/ListIdentities"
	IdentityService_DeleteIdentity_FullMethodName  = "/nexus.v1.IdentityService/DeleteIdentity"
	IdentityService_LinkPeer_FullMethodName        = "/nexus.v1.IdentityService/LinkPeer"
	IdentityService_UnlinkPeer_FullMethodName      = "/nexus.v1.IdentityService/UnlinkPeer"
	IdentityService_ResolveIdentity_FullMethodName = "/nexus.v1.IdentityService/ResolveIdentity"
	IdentityService_GetLinkedPeers_FullMethodName  = "/nexus.v1.IdentityService/GetLinkedPeers"
)

// IdentityServiceClient is the client API for IdentityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// IdentityService manages cross-channel identity linking.
// This allows mapping platform-specific user IDs (e.g., telegram:123456) to
// canonical identities for unified session management.
type IdentityServiceClient interface {
	// CreateIdentity creates a new canonical identity.
	CreateIdentity(ctx context.Context, in *CreateIdentityRequest, opts ...grpc.CallOption) (*CreateIdentityResponse, error)
	// GetIdentity retrieves an identity by canonical ID.
	GetIdentity(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error)
	// ListIdentities lists all identities.
	ListIdentities(ctx context.Context, in *ListIdentitiesRequest, opts ...grpc.CallOption) (*ListIdentitiesResponse, error)
	// DeleteIdentity deletes an identity and all its links.
	DeleteIdentity(ctx context.Context, in *DeleteIdentityRequest, opts ...grpc.CallOption) (*DeleteIdentityResponse, error)
	// LinkPeer links a platform-specific peer ID to a canonical identity.
	LinkPeer(ctx context.Context, in *LinkPeerRequest, opts ...grpc.CallOption) (*LinkPeerResponse, error)
	// UnlinkPeer removes a peer link from an identity.
	UnlinkPeer(ctx context.Context, in *UnlinkPeerRequest, opts ...grpc.CallOption) (*UnlinkPeerResponse, error)
	// ResolveIdentity resolves a platform peer ID to its canonical identity.
	ResolveIdentity(ctx context.Context, in *ResolveIdentityRequest, opts ...grpc.CallOption) (*ResolveIdentityResponse, error)
	// GetLinkedPeers returns all peer IDs linked to an identity.
	GetLinkedPeers(ctx context.Context, in *GetLinkedPeersRequest, opts ...grpc.CallOption) (*GetLinkedPeersResponse, error)
}

type identityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIdentityServiceClient(cc grpc.ClientConnInterface) IdentityServiceClient {
	return &identityServiceClient{cc}
}

func (c *identityServiceClient) CreateIdentity(ctx context.Context, in *CreateIdentityRequest, opts ...grpc.CallOption) (*CreateIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateIdentityResponse)
	err := c.cc.Invoke(ctx, IdentityService_CreateIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) GetIdentity(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIdentityResponse)
	err := c.cc.Invoke(ctx, IdentityService_GetIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) ListIdentities(ctx context.Context, in *ListIdentitiesRequest, opts ...grpc.CallOption) (*ListIdentitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListIdentitiesResponse)
	err := c.cc.Invoke(ctx, IdentityService_ListIdentities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) DeleteIdentity(ctx context.Context, in *DeleteIdentityRequest, opts ...grpc.CallOption) (*DeleteIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteIdentityResponse)
	err := c.cc.Invoke(ctx, IdentityService_DeleteIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) LinkPeer(ctx context.Context, in *LinkPeerRequest, opts ...grpc.CallOption) (*LinkPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LinkPeerResponse)
	err := c.cc.Invoke(ctx, IdentityService_LinkPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) UnlinkPeer(ctx context.Context, in *UnlinkPeerRequest, opts ...grpc.CallOption) (*UnlinkPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlinkPeerResponse)
	err := c.cc.Invoke(ctx, IdentityService_UnlinkPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) ResolveIdentity(ctx context.Context, in *ResolveIdentityRequest, opts ...grpc.CallOption) (*ResolveIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveIdentityResponse)
	err := c.cc.Invoke(ctx, IdentityService_ResolveIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) GetLinkedPeers(ctx context.Context, in *GetLinkedPeersRequest, opts ...grpc.CallOption) (*GetLinkedPeersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinkedPeersResponse)
	err := c.cc.Invoke(ctx, IdentityService_GetLinkedPeers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IdentityServiceServer is the server API for IdentityService service.
// All implementations must embed UnimplementedIdentityServiceServer
// for forward compatibility.
//
// IdentityService manages cross-channel identity linking.
// This allows mapping platform-specific user IDs (e.g., telegram:123456) to
// canonical identities for unified session management.
type IdentityServiceServer interface {
	// CreateIdentity creates a new canonical identity.
	CreateIdentity(context.Context, *CreateIdentityRequest) (*CreateIdentityResponse, error)
	// GetIdentity retrieves an identity by canonical ID.
	GetIdentity(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error)
	// ListIdentities lists all identities.
	ListIdentities(context.Context, *ListIdentitiesRequest) (*ListIdentitiesResponse, error)
	// DeleteIdentity deletes an identity and all its links.
	DeleteIdentity(context.Context, *DeleteIdentityRequest) (*DeleteIdentityResponse, error)
	// LinkPeer links a platform-specific peer ID to a canonical identity.
	LinkPeer(context.Context, *LinkPeerRequest) (*LinkPeerResponse, error)
	// UnlinkPeer removes a peer link from an identity.
	UnlinkPeer(context.Context, *UnlinkPeerRequest) (*UnlinkPeerResponse, error)
	// ResolveIdentity resolves a platform peer ID to its canonical identity.
	ResolveIdentity(context.Context, *ResolveIdentityRequest) (*ResolveIdentityResponse, error)
	// GetLinkedPeers returns all peer IDs linked to an identity.
	GetLinkedPeers(context.Context, *GetLinkedPeersRequest) (*GetLinkedPeersResponse, error)
	mustEmbedUnimplementedIdentityServiceServer()
}

// UnimplementedIdentityServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIdentityServiceServer struct{}

func (UnimplementedIdentityServiceServer) CreateIdentity(context.Context, *CreateIdentityRequest) (*CreateIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateIdentity not implemented")
}
func (UnimplementedIdentityServiceServer) GetIdentity(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetIdentity not implemented")
}
func (UnimplementedIdentityServiceServer) ListIdentities(context.Context, *ListIdentitiesRequest) (*ListIdentitiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListIdentities not implemented")
}
func (UnimplementedIdentityServiceServer) DeleteIdentity(context.Context, *DeleteIdentityRequest) (*DeleteIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteIdentity not implemented")
}
func (UnimplementedIdentityServiceServer) LinkPeer(context.Context, *LinkPeerRequest) (*LinkPeerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LinkPeer not implemented")
}
func (UnimplementedIdentityServiceServer) UnlinkPeer(context.Context, *UnlinkPeerRequest) (*UnlinkPeerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnlinkPeer not implemented")
}
func (UnimplementedIdentityServiceServer) ResolveIdentity(context.Context, *ResolveIdentityRequest) (*ResolveIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveIdentity not implemented")
}
func (UnimplementedIdentityServiceServer) GetLinkedPeers(context.Context, *GetLinkedPeersRequest) (*GetLinkedPeersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinkedPeers not implemented")
}
func (UnimplementedIdentityServiceServer) mustEmbedUnimplementedIdentityServiceServer() {}
func (UnimplementedIdentityServiceServer) testEmbeddedByValue()                         {}

// UnsafeIdentityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IdentityServiceServer will
// result in compilation errors.
type UnsafeIdentityServiceServer interface {
	mustEmbedUnimplementedIdentityServiceServer()
}

func RegisterIdentityServiceServer(s grpc.ServiceRegistrar, srv IdentityServiceServer) {
	// If the following call panics, it indicates UnimplementedIdentityServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IdentityService_ServiceDesc, srv)
}

func _IdentityService_CreateIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).CreateIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_CreateIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).CreateIdentity(ctx, req.(*CreateIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_GetIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).GetIdentity(ctx, req.(*GetIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_ListIdentities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListIdentitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).ListIdentities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_ListIdentities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).ListIdentities(ctx, req.(*ListIdentitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_DeleteIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).DeleteIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_DeleteIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).DeleteIdentity(ctx, req.(*DeleteIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_LinkPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).LinkPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_LinkPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).LinkPeer(ctx, req.(*LinkPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_UnlinkPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlinkPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).UnlinkPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_UnlinkPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).UnlinkPeer(ctx, req.(*UnlinkPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_ResolveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).ResolveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_ResolveIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).ResolveIdentity(ctx, req.(*ResolveIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_GetLinkedPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinkedPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).GetLinkedPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_GetLinkedPeers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).GetLinkedPeers(ctx, req.(*GetLinkedPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IdentityService_ServiceDesc is the grpc.ServiceDesc for IdentityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IdentityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nexus.v1.IdentityService",
	HandlerType: (*IdentityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateIdentity",
			Handler:    _IdentityService_CreateIdentity_Handler,
		},
		{
			MethodName: "GetIdentity",
			Handler:    _IdentityService_GetIdentity_Handler,
		},
		{
			MethodName: "ListIdentities",
			Handler:    _IdentityService_ListIdentities_Handler,
		},
		{
			MethodName: "DeleteIdentity",
			Handler:    _IdentityService_DeleteIdentity_Handler,
		},
		{
			MethodName: "LinkPeer",
			Handler:    _IdentityService_LinkPeer_Handler,
		},
		{
			MethodName: "UnlinkPeer",
			Handler:    _IdentityService_UnlinkPeer_Handler,
		},
		{
			MethodName: "ResolveIdentity",
			Handler:    _IdentityService_ResolveIdentity_Handler,
		},
		{
			MethodName: "GetLinkedPeers",
			Handler:    _IdentityService_GetLinkedPeers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/nexus.proto",
}
